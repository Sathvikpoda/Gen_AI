ğŸ“˜ Dialogflow CX Playbooks - Full Walkthrough with Real Example (README Style)

ğŸ¯ Goal

Create a Playbook to handle this student request:

"What is my quiz score and explain Chapter 3?"

Weâ€™ll build a Playbook that:

Collects student ID, quiz ID, and chapter name

Calls a Webhook to get quiz score

Calls Gemini (LLM) to summarize Chapter 3

Handles fallback if one tool fails

Uses versioning and staging before production


âœ… Step-by-Step Setup (README Style)

âœ… Step 1: Create the Intent

Intent Name: Student.ScoreAndSummary

Add training phrases:

"Whatâ€™s my quiz score and explain Chapter 3"

"Give me marks and summary"

Add parameters:

student_id (Required)

quiz_id (Required)

chapter_name (Required)

ğŸ§  This intent will trigger the Playbook.

âœ… Step 2: Create the Playbook

Playbook Name: QuizScoreAndChapterSummary

Define Parameters:

parameters:
  - name: student_id
    type: string
    required: true
  - name: quiz_id
    type: string
    required: true
  - name: chapter_name
    type: string
    required: true

âœ… Step 3: Add Tools to the Playbook

Tool 1: Webhook (Quiz Score)

tool:
  name: ScoreTask
  type: webhook
  endpoint: https://your-cloud-run-service/score
  method: POST
  payload:
    student_id: $student_id
    quiz_id: $quiz_id

Tool 2: Gemini LLM (Chapter Summary)

tool:
  name: SummaryTask
  type: llm
  model: gemini-pro
  prompt: "Summarize Chapter $chapter_name for a student in simple terms."
  temperature: 0.7

âœ… Step 4: Set Execution Mode

execution_mode: PARALLEL

ğŸ§  This runs both tools at the same time for faster response.

âœ… Step 5: Map Outputs

outputMappings:
  - from: ScoreTask.score
    to: score
  - from: SummaryTask.text
    to: summary

âœ… Step 6: Set Final Response Template

responseTemplates:
  - "You scored $score in Quiz $quiz_id. Here's a summary of Chapter $chapter_name: $summary"

âœ… Step 7: Handle Fallbacks

errorHandlers:
  - onFailure: SummaryTask
    fallbackMessage: "I couldnâ€™t fetch your score, but hereâ€™s the chapter summary."
  - onFailure: ScoreTask
    fallbackMessage: "Sorry, couldnâ€™t get the summary, but your score is $score."

ğŸ§  Playbooks let you define multiple fallback options based on which tool fails.

âœ… Step 8: Connect the Playbook to the Intent

In your Student.ScoreAndSummary intent route, select Call Playbook

Choose QuizScoreAndChapterSummary

ğŸ¯ Now when this intent is triggered, the Playbook runs.

âœ… Step 9: Version Control & Staging

Click Create Version from Playbook editor

Name it: v1-score-summary

Test in Staging Environment:

Add sample payloads

Verify Webhook and Gemini outputs




ğŸ§  ADK (Agent Development Kit) - Full README for Quiz Score + Chapter Summary Agent

ğŸ¯ Goal

Build a modular AI system using ADK where the user asks:

"What is my quiz score and explain Chapter 3?"

We'll create:

Two sub-agents:

ScoreAgent (calls API to get quiz score)

SummaryAgent (calls Gemini LLM to summarize chapter)

One SteeringAgent that:

Accepts user input

Runs both sub-agents in parallel

Combines the results

Optionally sends to LLM for final polishing

ğŸ§© Folder Structure

adk-student-helper/
â”œâ”€â”€ main.py
â”œâ”€â”€ steering_agent.py
â”œâ”€â”€ agents/
â”‚   â”œâ”€â”€ score_agent.py
â”‚   â””â”€â”€ summary_agent.py
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ score_tool.py
â”‚   â””â”€â”€ summary_tool.py
â”œâ”€â”€ schemas.py
â”œâ”€â”€ shared_context.py
â”œâ”€â”€ agent.yaml

âœ… Step-by-Step Instructions

ğŸ”¹ 1. Define Input/Output Schemas in schemas.py

from pydantic import BaseModel

class UserInput(BaseModel):
    student_id: str
    quiz_id: str
    chapter_name: str

class ScoreOutput(BaseModel):
    score: str

class SummaryOutput(BaseModel):
    summary: str

ğŸ”¹ 2. Build Score Tool in score_tool.py

from schemas import UserInput, ScoreOutput
from adk.classes import BaseTool

class ScoreTool(BaseTool):
    def run(self, input: UserInput) -> ScoreOutput:
        # Simulate DB/API call
        return ScoreOutput(score="85")

ğŸ”¹ 3. Build Summary Tool in summary_tool.py

from schemas import UserInput, SummaryOutput
from adk.classes import BaseTool
from vertexai.language_models import TextGenerationModel

class SummaryTool(BaseTool):
    def run(self, input: UserInput) -> SummaryOutput:
        model = TextGenerationModel.from_pretrained("gemini-pro")
        prompt = f"Summarize Chapter {input.chapter_name} in simple terms."
        result = model.predict(prompt)
        return SummaryOutput(summary=result.text)

ğŸ”¹ 4. Create Score Agent in score_agent.py

from adk.classes import BaseAgent
from schemas import UserInput, ScoreOutput
from tools.score_tool import ScoreTool

class ScoreAgent(BaseAgent):
    def run(self, input: UserInput) -> ScoreOutput:
        return ScoreTool().run(input)

ğŸ”¹ 5. Create Summary Agent in summary_agent.py

from adk.classes import BaseAgent
from schemas import UserInput, SummaryOutput
from tools.summary_tool import SummaryTool

class SummaryAgent(BaseAgent):
    def run(self, input: UserInput) -> SummaryOutput:
        return SummaryTool().run(input)

ğŸ”¹ 6. Create the Steering Agent in steering_agent.py

from schemas import UserInput
from agents.score_agent import ScoreAgent
from agents.summary_agent import SummaryAgent
from adk.classes import BaseSteeringAgent
import asyncio

class SteeringAgent(BaseSteeringAgent):
    async def run(self, input: UserInput):
        score_task = asyncio.create_task(ScoreAgent().run(input))
        summary_task = asyncio.create_task(SummaryAgent().run(input))

        score_result = await score_task
        summary_result = await summary_task

        return {
            "message": f"You scored {score_result.score}. Summary of Chapter {input.chapter_name}: {summary_result.summary}"
        }

ğŸ”¹ 7. Register and Run the Agent in main.py

from steering_agent import SteeringAgent
from schemas import UserInput
import asyncio

if __name__ == "__main__":
    input_data = UserInput(student_id="S123", quiz_id="Quiz1", chapter_name="3")
    result = asyncio.run(SteeringAgent().run(input_data))
    print(result["message"])

ğŸ›¡ï¸ Fallbacks (Manual)

In SteeringAgent, use try-except around each task

If a tool fails, return fallback response or run alternate tool

ğŸ§ª Version Control

Use Git to version the entire ADK project

Tag releases: v1.0, v1.1-fallbacks, etc.

Maintain separate branches for staging and prod agents




â€œThe working model of ADK and Playbooks is similar: both act like orchestration layers.
In Playbooks, I define Tasks like Webhook and LLM and connect them in a routine using execution order.
In ADK, I create tools in Python and use a SteeringAgent to route requests to sub-agents.
The difference is: Playbooks are no-code and work within Dialogflow CX; ADK is full-code and gives me total flexibility, like integrating external APIs, custom RAG logic, or parallel workflows.â€

âœ… High-Level Similarities
Feature	Playbooks                  (Dialogflow CX)	                        ADK (Agent Development Kit)
Modular logic	                   âœ… Yes (Tasks + Routines)	                âœ… Yes (Tools + Agents + Steering Agent)
Steering capability	           âœ… Main Playbook can call multiple Tasks	âœ… Steering Agent calls multiple Sub-Agents
Parallel/serial execution          âœ… Execution mode available	                âœ… Use asyncio or controlled logic
Reusable flows	                    âœ… Yes	                                âœ… Yes
Handles fallback	           âœ… With errorHandlers	                âœ… Manually via try/except
Output mapping	                    âœ… Yes	                                âœ… Yes via structured schema

â— Key Differences  
        Feature	                 Playbooks	                                	     ADK
Code required?	               âŒ No code, all config + GUI	                            âœ… Full Python code needed
LLM integration			Pre-integrated with Gemini, PaLM	                    Custom LLM logic (Gemini, OpenAI, Vertex, LangChain, etc.)
Extensibility           	Limited to tools offered in Dialogflow	 		    Highly extensible â€” integrate any Python logic, DBs, APIs, etc.
Use case complexity		Best for medium-complex flows in contact center/chatbots     Best for complex workflows, multi-agent orchestration
Deployment			Inside Dialogflow CX GUI				      Deployable anywhere (Cloud Run, GKE, local)


